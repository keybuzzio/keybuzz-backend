  /**
   * GET /api/v1/inbound-email/health/:connectionId
   * Get real health checks for specific connection
   */
  server.get("/api/v1/inbound-email/health/:connectionId", async (request, reply) => {
    try {
      const { connectionId } = request.params as { id: string };
      const tenantId = request.user?.tenantId;

      if (!tenantId) {
        return reply.status(403).send({ error: "Forbidden: no tenantId" });
      }

      // Verify connection belongs to tenant
      const connection = await prisma.inboundConnection.findUnique({
        where: { id: connectionId, tenantId },
      });

      if (!connection) {
        return reply.status(404).send({ error: "Connection not found" });
      }

      // Get all health checks
      const indicators = await getAllHealthChecks(connectionId, tenantId);

      // Calculate current status
      const status = await calculateConnectionStatus(connectionId);
      const actionMessage = getStatusActionMessage(status);

      return reply.send({
        connectionId,
        status,
        actionMessage,
        indicators,
      });
    } catch (error) {
      console.error("[InboundEmail] Error getting health:", error);
      return reply.status(500).send({ error: "Failed to get health status" });
    }
  });

  /**
   * POST /api/v1/inbound-email/dev/seed
   * Create demo connection with test data (DEV only)
   */
  server.post("/api/v1/inbound-email/dev/seed", async (request, reply) => {
    try {
      // Only allow in development
      if (process.env.NODE_ENV === "production") {
        return reply.status(403).send({ error: "Not available in production" });
      }

      const tenantId = request.user?.tenantId;
      if (!tenantId) {
        return reply.status(403).send({ error: "Forbidden: no tenantId" });
      }

      // Check if demo connection already exists
      const existing = await prisma.inboundConnection.findFirst({
        where: {
          tenantId,
          marketplace: "AMAZON",
        },
      });

      if (existing) {
        return reply.send({
          message: "Demo connection already exists",
          connectionId: existing.id,
        });
      }

      // Create demo connection
      const { ensureInboundConnection } = await import("./inboundEmailAddress.service");
      const connection = await ensureInboundConnection(tenantId, "AMAZON" as any, ["FR", "DE", "UK"]);

      // Auto-validate FR address for demo
      if (connection) {
        const frAddress = await prisma.inboundAddress.findFirst({
          where: {
            connectionId: connection.id,
            country: "FR",
          },
        });

        if (frAddress) {
          await prisma.inboundAddress.update({
            where: { id: frAddress.id },
            data: {
              validationStatus: "VALIDATED",
              lastInboundAt: new Date(),
            },
          });
        }

        // Update status
        await updateConnectionStatus(connection.id);
      }

      return reply.send({
        message: "Demo connection created",
        connectionId: connection?.id,
      });
    } catch (error) {
      console.error("[InboundEmail] Error seeding demo:", error);
      return reply.status(500).send({ error: "Failed to create demo connection" });
    }
  });
}
